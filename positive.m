(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ad[u_,rho_] := u.rho.u\[ConjugateTranspose];


a_\[CircleTimes]b_:= KroneckerProduct[a,b];


\[LeftAngleBracket]a_List,b_List\[RightAngleBracket]:=(a\[ConjugateTranspose].b)[[1,1]];


c[a_,b_]:=a.b-b.a;


makematrix[str_,size_] := Table[ ToExpression[ str<>ToString[i]<>"m"<>ToString[j]], {i,1,size}, {j, 1, size}];


mx[str_,size_] := Table[ Subscript[str,i,j], {i,1,size}, {j, 1, size}];


mx[str_,sizex_,sizey_] := Table[ Subscript[str,i,j], {i,1,sizex}, {j, 1, sizey}];


samx[str_,size_] := Table[ If[i<=j,Subscript[str,i,j],Conjugate[Subscript[str,j,i]]], {i,1,size}, {j, 1, size}];


ux[phi_] := {{Cos[phi], I Sin[phi]}, {I Sin[phi], Cos[phi]}}
uy[phi_] := {{Cos[phi], Sin[phi]}, {-Sin[phi], Cos[phi]}}
uz[theta_] := {{Exp[I theta], 0}, {0, Exp[-I theta]}}
un[\[Xi]_, \[Eta]_, \[Zeta]_]:= {{Exp[I \[Xi]] Cos[\[Eta]], Exp[I \[Zeta]] Sin[\[Eta]]}, {-Exp[-I \[Zeta]]Sin[\[Eta]], Exp[-I \[Xi]] Cos[\[Eta]]}}


e[n_Integer, dim_] := {ReplacePart[#, n->1] & @ Table[0, {dim}]}\[Transpose];
u[a_,b_] := {{a,b}, {-b\[Conjugate], a\[Conjugate]}};
proj[v_?(ArrayDepth[#]==2&)] := 1/(Norm[v]^2)v.v\[ConjugateTranspose];
proj[v_?(ArrayDepth[#]==1 &)] := proj[{v}\[Transpose]];
proj[v_,w_] := 1/(Norm[v]Norm[w])v.w\[ConjugateTranspose];
tau[dim_]:= Sum[ KroneckerProduct[e[i,dim],e[i,dim]], {i,1,dim}];


cVec[v_]:={v}\[Transpose];
rVec[v_]:=(v\[Transpose])[[1]]


bpSemiDefiniteQ4[m_]:=Module[{f1,f2,g1,g2, fg}, 	
fg = {{f1 g1,f1 g2,f2 g1,f2 g2}};Resolve[ ForAll[ {f1,f2,g1,g2}, GreaterEqual[#,0]& @@ Flatten[fg.m.fg\[HermitianConjugate]]], Complexes]]
bpSemiDefiniteQ9[m_]:=Module[{f1,f2, f3,g1,g2, g3, fg}, 	
fg = {{f1 g1,f1 g2, f1 g3,f2 g1,f2 g2, f2 g3, f3 g1, f3 g2, f3 g3}};Resolve[ ForAll[ {f1,f2, f3,g1,g2, g3}, GreaterEqual[#,0]& @@ Flatten[fg.m.fg\[HermitianConjugate]]], Complexes]]
bpFailQ4[m_List?MatrixQ] := Module[{f1,f2,g1,g2, fg}, 	
fg = {{f1 g1,f1 g2,f2 g1,f2 g2}};FindInstance[ Less[#,0]& @@ Flatten[fg.m.fg\[HermitianConjugate]], {f1,f2,g1,g2}, Complexes]]
symmetryQ[m_List?MatrixQ] := m.m == IdentityMatrix@Length@m &&m\[HermitianConjugate]==m
symmetryNQ[m_List?MatrixQ] := Chop[m.m//N] == IdentityMatrix@Length@m &&m\[HermitianConjugate]==m
SpecialUnitaryQ[m_List?MatrixQ]:=(Conjugate@Transpose@m.m==IdentityMatrix@Length@m&&Det[m]==1)


partialSymmetryQ[m_] := m.m.m.m == m.m
partialSymmetryRank[m_] := If[partialSymmetryQ[m], Tr[m.m], False]
partialSymmetryDiff[m_] := Plus@@(Power[#,2]&/@ (Flatten@(m.m.m.m-m.m))) //N


partialTranspose[m_]:= ArrayFlatten[Map[ Transpose, Partition[m,{Sqrt[Length[m]],Sqrt[Length[m]]}], {2}]]


partialTr[m_]:= ArrayFlatten[Map[ Tr, Partition[m,{Sqrt[Length[m]],Sqrt[Length[m]]}], {2}]]


findRho[ f_, d_ ]:=Module[ {a,b, rho,vars, sol},
a = makematrix["a",d];
b = makematrix["b", d];
rho = makematrix["rho", d d];
vars = Flatten[KroneckerProduct[a,b]];
sol =SolveAlways[ Collect[Tr[f[a].b\[Transpose]] - Tr[rho.KroneckerProduct[a,b]], vars] == 0, Join[Flatten[a], Flatten[b]]];
Flatten[rho /. sol, 1]
]


\[Rho][\[Xi]_,\[Eta]_, \[Zeta]_] := findRho[(ux[\[Xi]].uy[\[Eta]].uz[\[Zeta]])\[ConjugateTranspose]. Transpose[#].ux[\[Xi]].uy[\[Eta]].uz[\[Zeta]] &, 2];


findRhoChoi[map_,dim_] :=  Sum[ KroneckerProduct[proj[e[i,dim],e[j,dim]], map[proj[e[i,dim],e[j,dim]]]],{i,1,dim},{j,1,dim}]


kroneckize[x_, spec_, dim_] := x KroneckerProduct[e[spec[[2]],dim], e[spec[[1]],dim]];


matrixToLinear[m_] := Plus @@ Flatten[MapIndexed[ kroneckize[#1, #2, Length[m]] &, m, {2}], 1];
linearToMatrix[l_] := Partition[Flatten[l], Sqrt[Length[l]]]\[Transpose];


kProd[a_,b_] := matrixToLinear[linearToMatrix[a].linearToMatrix[b]];
kron[a_]:= matrixToLinear[a];
dekron[a_]:=linearToMatrix[a];
kTr[a_] := Module[{tau}, tau = Plus@@Table[KroneckerProduct[e[i,Sqrt[Length[a]]],e[i,Sqrt[Length[a]]]],{i,1,Sqrt[Length[a]]}]; Plus@@Flatten[tau\[ConjugateTranspose].a]];


uKroneckerProductRule[dim_]:=Module[ {rho,a,b,map, t1,t2,rlist, result},
a= makematrix["a", dim]; b=makematrix["b",dim]; map=makematrix["map",dim^2]; rho = makematrix["rho",dim^2];
t1 = matrixToLinear[KroneckerProduct[a,b]]-KroneckerProduct[matrixToLinear[a], matrixToLinear[b]];
t2 =Simplify /@ Abs /@ Select[Flatten[t1], #=!= 0&];
rlist =Flatten[{#,Reverse[#]} & /@ DeleteDuplicates@((Flatten @ Position[ Simplify /@ Abs /@ Flatten[t1], #]&) /@ t2),1];
result=ReplacePart[Table[0,{dim^4},{dim^4}],rlist-> 1];
result=ReplacePart[result, ({#,#}&/@(Flatten@Position[result, Table[0,{dim^4}]]))->1]
];


stormer2kron[rho_] := dekron[uKroneckerProductRule[Sqrt[Length[rho]]].kron[rho\[Transpose]]];
kron2stormer[phi_]:=dekron[uKroneckerProductRule[Sqrt[Length[phi]]].kron[phi]]\[Transpose];


ukro3 = uKroneckerProductRule[3];
fastk2s3[phi_] := dekron[ukro3.kron[phi]]


findPhi[f_,dim_]:=Module[ {map, a},
a = makematrix["a",dim];
map = makematrix["map",dim^2];
map /. (Flatten@SolveAlways[ map.kron[a] == kron[f[a]], Flatten@a])
]


(*actbyrho[rho_,m_]:= dekron[stormer2kron[rho].kron[m]];
actByRho[rho_,m_]:= dekron[stormer2kron[rho].kron[m]];
partialActByRho[rho_,m_]:= Module[{ukro},
ukro=uKroneckerProductRule[Sqrt[Length[m]]];
dekron[ ukro.KroneckerProduct[IdentityMatrix[Length[m]],stormer2kron[rho]].ukro.kron[m]]]*)


actByRho[rho_]:=Function[m,
partialTr[(m\[Transpose]\[CircleTimes]IdentityMatrix[Length[m]]).rho,1]]


transform[rho_, \[Xi]_,\[Eta]_, \[Zeta]_] := Chop[ad[ \[Rho][\[Xi],\[Eta],\[Zeta]/2].\[Rho][\[Xi],\[Eta]/2, 0].\[Rho][\[Xi]/2,0,0],rho] //N];


transform2[rho_, \[Xi]_,\[Eta]_, \[Zeta]_] := Chop[ad[\[Rho][\[Xi]/2,0,0]. \[Rho][\[Xi],\[Eta]/2, 0].\[Rho][\[Xi],\[Eta],\[Zeta]/2],rho]//N];


stormerExtreme[\[Alpha]_, \[Beta]_, \[Gamma]_, \[Delta]_, \[Epsilon]_]:=Function[x,
{{x[[1,1]], \[Alpha] x[[1,2]] + \[Beta] x[[2,1]]},
{Conjugate[\[Alpha]] x[[2,1]] + Conjugate[\[Beta]]x[[1,2]], \[Gamma] x[[1,1]] + \[Epsilon] x[[1,2]] + Conjugate[\[Epsilon]]x[[2,1]] + \[Delta] x[[2,2]]}}]


rhoIdentity = findRho[#&,3];


rhoTranspose = findRhoChoi[Transpose,3];


h = 1/2 Sqrt[1+Sqrt[5]]; NN = 2/Sqrt[5+Sqrt[5]];


v[i_] := NN  {{Cos[2\[Pi] i/5]}, {Sin[2\[Pi] i/5]}, {h}};


unextprodbase = {v[#[[1]]],v[#[[2]]]} &/@Table[ {i,Mod[ 2 i, 5]}, {i,0,4}];


unextRho[upb_] := Module[{p1,dim, S},
dim = Length[upb[[1,1]]];
S = Length[upb];
1/(dim^2-S)(IdentityMatrix[dim^2] -Plus@@(KroneckerProduct[Sequence @@#]&/@({proj@#[[1]], proj@#[[2]]} &/@upb)))
]


Psi[a_,b_,c_,m_] := DiagonalMatrix[ {a m[[1,1]] + b m[[2,2]] + c m[[3,3]], a m[[2,2]] + b m[[3,3]] + c m[[1,1]], a m[[3,3]] + b m[[1,1]] + c m[[2,2]]}]
choi[m_] :=Psi[2,0,1,m] - m;
choiorig[m_] := Psi[2,2,2,m] -m;
choi[m_,mu_]:=Psi[2,0,mu,m] -m;
choi[m_,a_,b_,c_]:=Psi[a,b,c,m] -m;


rhoChoi = findRhoChoi[1/2 choi[#]&,3];


terhalmu = (4+Sqrt[2]-Sqrt[5]-Sqrt[10])/9;
terhalproj[i_,j_,mu_] := Sum[ Sequence@@Flatten@(e[i,3]\[ConjugateTranspose].v[k])Sequence@@Flatten@( v[k]\[ConjugateTranspose].e[j,3]) (v[Mod[2k,5]].v[Mod[2k,5]]\[ConjugateTranspose]), {k,0,4}] - mu e[i,3].e[j,3]\[ConjugateTranspose];
terhalmap[m_] := Sum[ m[[i,j]] terhalproj[i,j,terhalmu], {i,1,3},{j,1,3} ];
terhal[m_] := Sum[ m[[i,j]] terhalproj[i,j,terhalmu], {i,1,3},{j,1,3} ];
terhalmap[m_,mu_] := Sum[ m[[i,j]] terhalproj[i,j,mu], {i,1,3},{j,1,3} ];
terhalMapNormalizator=MatrixPower[Inverse[terhalmap[IdentityMatrix[3]]],1/2];
normalizedTerhal[m_]:=terhalMapNormalizator.terhal[m].terhalMapNormalizator;


rhoTerhal = findRhoChoi[terhal,3];
rhoNormalizedTerhal = findRhoChoi[normalizedTerhal,3];


rhoMaj0 = proj@(1/Sqrt[2](e[1,3]\[CircleTimes]e[2,3]+e[2,3]\[CircleTimes]e[1,3]))+
proj@(e[1,3]\[CircleTimes]e[1,3])+
proj@(e[2,3]\[CircleTimes]e[2,3])+
proj@(e[1,3]\[CircleTimes]e[3,3])-
proj@(1/Sqrt[2](e[1,3]\[CircleTimes]e[2,3]-e[2,3]\[CircleTimes]e[1,3]));


maj0[m_]:=actByRho[rhoMaj0,m];


majGeneratingVectors =1/Sqrt[3] {( e[1,3]\[CircleTimes]e[2,3]+e[2,3]\[CircleTimes]e[3,3]+e[3,3]\[CircleTimes]e[1,3]),( e[2,3]\[CircleTimes]e[1,3]+e[3,3]\[CircleTimes]e[2,3]+e[1,3]\[CircleTimes]e[3,3]),( e[1,3]\[CircleTimes]e[1,3]+e[2,3]\[CircleTimes]e[2,3]+e[3,3]\[CircleTimes]e[3,3])};


rhoMaj1 = 3 partialTranspose[proj@majGeneratingVectors[[1]]];


maj1[m_]:=actByRho[rhoMaj1,m];


rhoMaj2=3 partialTranspose[proj@majGeneratingVectors[[2]]];


maj2[m_]:=actByRho[rhoMaj2,m];


rhoMaj3=3 partialTranspose[proj@majGeneratingVectors[[3]]];


maj3[m_]:=actByRho[rhoMaj3,m];


robertsonred[m_] := IdentityMatrix[2] Tr[m] - m;
robertsonmap[m_] := Module[ {r11, r12, r21,r22},
r11 = IdentityMatrix[2] Tr[ m[[3;;4,3;;4]] ];
r22 = IdentityMatrix[2] Tr[ m[[1;;2,1;;2]] ];
r12 = m[[1;;2, 3;;4]]+robertsonred[ m[[3;;4,1;;2]] ];
r21 = m[[3;;4,1;;2]] +robertsonred[ m[[1;;2,3;;4]] ];
1/2ArrayFlatten[{{r11,r12},{r21,r22}}]
];


p0[dim_] := proj@(Plus@@(Table[KroneckerProduct[e[i,dim],e[i,dim]],{i,1,dim}]))


unextrho = unextRho[unextprodbase];


hrho = 1/(8q+1){{q,0,0,0,q,0,0,0,q},
{0,q,0,0,0,0,0,0,0},
{0,0,q,0,0,0,0,0,0},
{0,0,0,q,0,0,0,0,0},
{q,0,0,0,q,0,0,0,q},
{0,0,0,0,0,q,0,0,0},
{0,0,0,0,0,0,1/2(1+q), 0, 1/2Sqrt[1-q^2]},
{0,0,0,0,0,0,0,q,0},
{q,0,0,0,q,0,1/2Sqrt[1-q^2],0,1/2(1+q)}};


randomPositivityTest[phi_,nb_] := Module[{t,rm,i=0},
For[i,i<nb,i++,
t =  RandomReal[{-1,1},{3,3}] + I RandomReal[{-1,1},{3,3}];
rm = phi[t\[ConjugateTranspose].t] //Chop;
If[ Min@Chop@Eigenvalues[rm] <0, 
	Break[]]];
If[i==nb,True,{Min@Chop@Eigenvalues[rm],t\[ConjugateTranspose].t}]]
randomCheckNormalization[map_,trials_] := Module[{t,rm,i=0},
For[i,i<trials,i++,
t= RandomReal[{-1,1},{3,3}] + I RandomReal[{-1,1},{3,3}];
rm = map[t];
If[Norm[rm]>Norm[t],Break[]]];
If[i==trials,True,False]];
randomNorm[map_,trials_]:=Module[{t,rm,i=0,n},
n=0;
For[i,i<trials,i++,
t= RandomReal[{-1,1},{3,3}] + I RandomReal[{-1,1},{3,3}];
rm = map[t];
If[Norm[rm]/Norm[t]>=n,n=Norm[rm]/Norm[t],Null]];
n];


randomPositivityTest[phi_,nb_,dim_] := Module[{t,rm,i=0},
For[i,i<nb,i++,
t =  RandomReal[{-1,1},{dim,dim}] + I RandomReal[{-1,1},{dim,dim}];
rm = phi[t\[ConjugateTranspose].t] //Chop;
If[ Min@Chop@Eigenvalues[rm] <0, 
	Break[]]];
If[i==nb,True,{Min@Chop@Eigenvalues[rm],t\[ConjugateTranspose].t}]]


makeRandomBpTest[s_]:={Chop@((#\[ConjugateTranspose].s.#)[[1,1]]),#}&[CircleTimes@@({#}\[Transpose]/Norm[#]&/@{RandomReal[{-1,1},3]+I RandomReal[{-1,1},3],RandomReal[{-1,1},3]+I RandomReal[{-1,1},3]})]
randomBpTest[s_,n_]:=Select[Table[makeRandomBpTest[s], {n}],#[[1]]<0&]


makeRandomBpTest[s_,dim_]:={Chop@((#\[ConjugateTranspose].s.#)[[1,1]]),#}&[CircleTimes@@({#}\[Transpose]/Norm[#]&/@{RandomReal[{-1,1},dim]+I RandomReal[{-1,1},dim],RandomReal[{-1,1},dim]+I RandomReal[{-1,1},dim]})]
randomBpTest[s_,dim_,n_]:=Select[Table[makeRandomBpTest[s,dim], {n}],#[[1]]<0&]


antimorphismQ[\[Phi]_]:=With[{a=mx["a",3],b=mx["b",3]}, \[Phi][a.b] - \[Phi][b].\[Phi][a]==Array[0&,{3,3}]//FullSimplify];
morphismQ[\[Phi]_]:=With[{a=mx["a",3],b=mx["b",3]}, \[Phi][a.b] - \[Phi][a].\[Phi][b]==Array[0&,{3,3}]//FullSimplify];


antimorphismQ[\[Phi]_,dim_]:=With[{a=mx["a",dim],b=mx["b",dim]}, \[Phi][a.b] - \[Phi][b].\[Phi][a]==Array[0&,{dim,dim}]//FullSimplify];
morphismQ[\[Phi]_,dim_]:=With[{a=mx["a",dim],b=mx["b",dim]}, \[Phi][a.b] - \[Phi][a].\[Phi][b]==Array[0&,{dim,dim}]//FullSimplify];


bpTest[rho_,x_,y_]:=\[LeftAngleBracket]x\[CircleTimes]y, rho.(x\[CircleTimes]y)\[RightAngleBracket] >=0


HSinner[a_,b_]:=Tr[a\[ConjugateTranspose].b];
HScoeff[a_,i_,j_,k_,l_]:=With[{n=Sqrt@Length@a},HSinner[proj[e[i,n],e[j,n]]\[CircleTimes]proj[e[k,n],e[l,n]],a]];
partialMap[map_,a_]:=Plus@@(Function[{i,j,k,l},HScoeff[a,i,j,k,l] proj[e[i],e[j]]\[CircleTimes]map[proj[e[k],e[l]]]][Sequence@@#]&/@Tuples[Range[3],4])


vecCoeff[v_,i_,j_]:=With[{n=Length@Transpose@v},\[LeftAngleBracket]e[i,n]\[CircleTimes]e[j,n],v\[RightAngleBracket]];


GellMannMatrices ={ ({{0,1,0},{1,0,0},{0,0,0}}),
({{0,-I,0},{I,0,0},{0,0,0}}),
({{1,0,0},{0,-1,0},{0,0,0}}),
({{0,0,1},{0,0,0},{1,0,0}}),
({{0,0,-I},{0,0,0},{I,0,0}}),
({{0,0,0},{0,0,1},{0,1,0}}),
({{0,0,0},{0,0,-I},{0,I,0}}),
Sqrt[1/3] ({{1,0,0},{0,1,0},{0,0,-2}}),
({{1,0,0},{0,1,0},{0,0,1}})};

su[angles_]:=Dot@@(MatrixExp[I GellMannMatrices[[#[[1]]]] #[[2]]]&/@({{3,2,3,5,3,2,3,8},angles}\[Transpose]))


basis3[alpha_]:= su[alpha].# &/@{e[1,3],e[2,3],e[3,3]}


bsyms3[basis_]:={proj[basis[[1]]]+proj[basis[[2]]]-proj[basis[[3]]],  proj[basis[[2]]]+proj[basis[[3]]]-proj[basis[[1]]],
proj[basis[[3]]]+proj[basis[[1]]]-proj[basis[[2]]]}


sym3=With[{alpha=Table[ToExpression["\[Alpha]"<>ToString[i]],{i,1,8}]},bsyms3[basis3[alpha]]];





NAlphaNorm[m_]:= With[{x={{x1,x2,x3}}\[Transpose],alpha=Table[ToExpression["\[Alpha]"<>ToString[i]],{i,1,8}]},
Max[NMaxValue[{Abs@Tr[m.(#\[CircleTimes]proj@x)], Norm[x]==1},Flatten[Join[alpha,x]]] &/@ sym3]]


NAlphaNormResult[m_]:= With[{x={{x1,x2,x3}}\[Transpose],alpha=Table[ToExpression["\[Alpha]"<>ToString[i]],{i,1,8}]},
NMaximize[{Abs@Tr[m.(#\[CircleTimes]proj@x)], Norm[x]==1},Flatten[Join[alpha,x]]] &/@ sym3]


alphaNormGateauxDiff[x_,y_,\[Lambda]_]:=(NAlphaNorm[x+\[Lambda] y] - NAlphaNorm[x])/\[Lambda]


NAlphaNormBP[m_]:=With[{x={{x1,x2,x3}}\[Transpose]},NMaxValue[{Abs@Tr[m.(IdentityMatrix[3]\[CircleTimes](proj@x))], Norm[x]==1},Flatten[x]]];


partialTr[m_,2]:=With[{n=Sqrt@Length@m},Sum[Sum[Tr[m.proj[e[i,n]\[CircleTimes]e[k,n],e[j,n]\[CircleTimes]e[k,n]]],{k,n}] proj[e[j,n],e[i,n]],{i,n},{j,n}] ]
partialTr[m_,1]:=With[{n=Sqrt@Length@m},Sum[Sum[Tr[m.proj[e[k,n]\[CircleTimes]e[i,n],e[k,n]\[CircleTimes]e[j,n]]],{k,n}] proj[e[j,n],e[i,n]],{i,n},{j,n}] ]


pureStateEntangledQ[v_]:=If[Tr[partialTr[proj@v,1].partialTr[proj@v,1]]<1,True,False];


ubasetransform[v_,b1_,b2_]:= Sum[(b1[[i]]\[ConjugateTranspose].v)[[1,1]] b2[[i]], {i,1,Length[v]}];


schmidtCoeff[v_]:=With[{n=Sqrt@Length@v},SingularValueList@ArrayFlatten@Table[ (e[i,n]\[CircleTimes]e[j,n])\[ConjugateTranspose].v, {i,n},{j,n}]]


schmidtDecomposition[v_]:={Select[Diagonal@#[[2]],#>0&],{#[[1]]\[Transpose],#[[3]]\[Transpose]}\[Transpose][[1;;Length@Select[Diagonal@#[[2]],#>0&]]]}&[SingularValueDecomposition@ArrayFlatten@Table[ (e[i,3]\[CircleTimes]e[j,3])\[ConjugateTranspose].v, {i,3},{j,3}]]


schmidtCoeff[v_]:=With[{n=Sqrt@Length@v},SingularValueList@ArrayFlatten@Table[ (e[i,n]\[CircleTimes]e[j,n])\[ConjugateTranspose].v, {i,n},{j,n}]]


schmidtDecomposition[v_]:=With[{n=Sqrt@Length@v},{Select[Diagonal@#[[2]],#>0&],{#[[1]]\[Transpose],#[[3]]\[Transpose]}\[Transpose][[1;;Length@Select[Diagonal@#[[2]],#>0&]]]}&[SingularValueDecomposition@ArrayFlatten@Table[ (e[i,n]\[CircleTimes]e[j,n])\[ConjugateTranspose].v, {i,n},{j,n}]]]


columnNormalize[v_]:={Normalize[Transpose[v][[1]]]}\[Transpose]


revec[a_]:=With[{m=Length@a,n=Length@Transpose@a},
	Transpose@{Join@@(Table[a[[1;;m,i]],{i,1,n}])}];
rearrangedMatrix[a_,bs_]:=Plus@@Flatten[(revec/@Flatten[Partition[ a,{bs,bs}],1]),{3}];
rearrangedMatrix[a_]:=rearrangedMatrix[a,Sqrt[Length[a]]];


stateEPR = 1/Sqrt[2](e[1,3]\[CircleTimes]e[1,3]+e[2,3]\[CircleTimes]e[2,3]);


stateEPRm = 1/Sqrt[2](e[1,3]\[CircleTimes]e[1,3]-e[2,3]\[CircleTimes]e[2,3]);


stateEPR3 = 1/Sqrt[3](e[1,3]\[CircleTimes]e[1,3]-e[2,3]\[CircleTimes]e[2,3]+e[3,3]\[CircleTimes]e[3,3]);


stateEPR3m = 1/Sqrt[3](e[1,3]\[CircleTimes]e[2,3]-e[2,3]\[CircleTimes]e[3,3]+e[3,3]\[CircleTimes]e[1,3]);
